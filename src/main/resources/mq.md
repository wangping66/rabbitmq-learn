####1:MQ的作用
#####&ensp;&ensp;(1):解耦，一个业务需要多个模块实现，或者一个消息有多个系统需要处理，只要主业务完成，发送一条mq消息，其余模块消费mq消息，这样就降低模块之间的耦合。
#####&ensp;&ensp;(2):异步,(个人感觉这个和解耦差不多)主业务执行任务后从属业务通过mq,异步执行，降低业务响应时间，提高用户体验。
#####&ensp;&ensp;(3):流量削峰,高并发下，业务异步处理，提高系统高峰时期处理业务的能力,避免系统瘫痪。
####2:MQ的缺点
#####&ensp;&ensp;(1):系统可用性降低。依赖服务越多，服务越容易挂掉，需要考虑mq挂掉的情况
#####&ensp;&ensp;(2):系统复杂度提高。需要考虑消息丢失，重复消费，消费顺序的问题。
#####&ensp;&ensp;(3):业务一致性(个人不太懂这个),主业务和从属业务一致性的处理。
####3:MQ使用场景: 那么使用消息队列的情况需要满足什么条件呢？
#####&ensp;&ensp;(1):生产者不需要从消费者处获取反馈,接口的返回值为空，下层的动作明明没有执行，上层缺当成动作已经完成了继续往后走。
#####&ensp;&ensp;(2):容许短暂的不一致性,不是非常理解，感觉还是跟(1)是一个意思。
####4:rabbitmq中exchange type
1. Direct Change 直接路由转发,消息中的routing-key与exchange中的binding-key匹配，相同则发送到这个queue
2. Fanout exchange 复制分发路由,当exchange收到消息时,将消息复制多分直接转发给与自己绑定的queue中
3. topic exchange 通配路由,这种就第一种的路由匹配，没啥特殊的，就是模糊匹配。

####5:Message durability
rabbitMq的消息在会存在磁盘中,这里暂时我没理解它说的磁盘节点和内存节点是啥，会根据这个的不同，消息在不同时间段保存到磁盘或者内存中
####6: message ack
实际使用中，消费者收到queue中的消息，还未来得及处理，就挂了，那这条消息可能就丢失了，可以在消费消费完某条消息时，发送一个回执给rabbitMq，只有受到回执才删除这条消息。
如果一个queue没被任何一个Consumer Subscribe的话，发送到他的message会cache,不会被丢弃，(我试验过)，当有Consumer时，这个数据会被立即发送到这个Consumer。这个数据被Consumer正确收到时，这个数据就被从Queue中删除(试验验证过)
那么什么是正确收到呢？通过ACK。每个Message都要被acknowledged（确认，ACK）。我们可以显示的在程序中去ACK，也可以自动的ACK。如果有数据没有被ACK，那么RabbitMQ Server会把这个信息发送到下一个Consumer。
####7:生产者消息确认机制,
1. 在我印象中，一般好像没在这方面做啥处理，都是默认消息成功发送到exchange中。
####8: 消费者消息确认机制
1. 为了保证消息从队列可靠地到达消费者，
RabbitMQ提供了消费者消息确认机制（message acknowledgement）。
采用消息确认机制之后，消费者就有足够的时间来处理消息，
用担心处理消息过程中消费者进程挂掉后消息丢失的问题，
因为RabbitMQ会一直等待并持有消息，直到消费者确认了该消息。
####9:死信队列
1.  当消息在一个队列中变成死信（dead message）时，
    通过这个交换机将死信发送到死信队列中（指定好相关参数，rabbitmq会自动发送）。
2. 什么是死信呢？什么样的消息会变成死信呢？
   1. 消息被拒绝（basic.reject或basic.nack）并且requeue=false.
   2. 消息TTL过期
   3. 队列达到最大长度（队列满了，无法再添加数据到mq中）
####10:消息确认的进一步讨论
为解决消息自动确认后消费者异常，导致消息丢失的问题，使用了手工确认的方案，
只有在消息处理成功后，才向RabbitMQ服务端返回确认。
若在消息处理过程中出现异常，
则消费者在恢复后，消息依然保留在队列中，可交由消费者重新处理，避免了消息的丢失。
但仅此还不够，若在消费者处理消息成功后、
返回确认ACK之前出现异常，
或在传输ACK消息的过程中，网络出现异常，
导致ACK未发送给RabbitMQ服务端，
会出现什么情况呢？这条消息将会作为未确认的消息留在队列中，
并在信道断开后，
交由其他消费者进行处理，这就造成同一个消息被处理2次，
若这是一笔转账消息，后果很严重，这笔转账将会被转双倍的钱。
要解决以上问题，
需要要求消费者对消息的处理具有幂等性，
即消息处理一次与处理多次效果相同。通常在消费者端维护一个列表，
记录被处理过的消息，消费者收到消息后，首先查询该列表，
若消息已被处理则丢弃，否则才继续处理。